#!/usr/bin/python

# mer-kickstarter tool to convert .yaml files to .ks files
# Copyright (C) 2011 Anas Nashif <anas.nashif@intel.com>
# Copyright (C) 2012 Marko Saukko <marko.saukko@jollamobile.com>
 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import yaml
import sys
import os
import copy
import optparse
import errno

from kickstart import kickstart

def mkdir_p(path):
    try:
        os.makedirs(path)
    except OSError as exc: # Python >2.5
        if exc.errno == errno.EEXIST:
            pass
        else: raise

class KSWriter():
    def __init__(self, out):
        self.outdir = out
        self.extra = {}
        pass
      
    def merge(*input):
        return list(reduce(set.union, input, set()))

    def __merge_dictionaries(self, first, second):
        out = copy.copy(first)
        for k,v in second.iteritems():
            if out.has_key(k):
                if isinstance(out[k], list) and isinstance(v, list):
                    temp = copy.copy(v)
                    temp.extend(out[k])
                    out[k] = temp
                elif isinstance(out[k], list) or isinstance(v, list):
                    sys.exit("Error: Type mismatch. Can not combine list with non-list for field '%s'" % k)
                else:
                    out[k] = v
            else:
                out[k] = v
        return out
    
    def __read_config_file(self, image_meta,config_file):
        output = ''
        path = None
        if os.path.exists(config_file):
            path = config_file
        elif image_meta.has_key('ExternalConfigs'):
            for extconfdir in image_meta['ExternalConfigs']:
                if os.path.exists('%s/%s' % (extconfdir,config_file)):
                    path = '%s/%s' % (extconfdir,config_file)
                    break
        if path:
            f = open(path, 'r')
            output += f.read()
            output += "\n"
            f.close()
        else:
            print 'WARNING: %s not found, skipping.' % config_file
        return output
    
    def __recursive_inherit(self, conf, image_meta, already_inherited):
        if conf.has_key("Inherit") and conf["Inherit"]:
            inherit_list = conf["Inherit"]
            conf["Inherit"] = []
            for x in inherit_list:
                if x in already_inherited:
                    continue
                already_inherited.append(x)
                if not image_meta.has_key(x):
                    print "WARNING: Unable to find inherit section '%s' ignoring." % x
                    continue
                print "Merging %s" % (x)
                conf = self.__merge_dictionaries(conf, image_meta[x])
            conf = self.__recursive_inherit(conf, image_meta, already_inherited)
        return conf

    def parse(self, image_meta, configuration):
        conf = {}
        
        already_inherited = []
        if configuration.has_key('Inherit') and configuration["Inherit"]:
            conf = self.__recursive_inherit(configuration, image_meta, already_inherited)
        
        postscript = ""
        if conf.has_key('PostScripts'):
            for scr in conf['PostScripts']:
                postscript += self.__read_config_file(image_meta,scr)

        nochrootscript = ""
        if conf.has_key('NoChrootScripts'): 
            for scr in conf['NoChrootScripts']:
                nochrootscript += self.__read_config_file(image_meta,scr)

        if conf.has_key("Part"):
            part_output = self.__read_config_file(image_meta,conf['Part'])
            if part_output != '':
               conf['Part'] = part_output
            else:
                print "WARNING: %s not found" % partfn
                del conf['Part']

        if postscript:
            conf['Post'] = postscript
        if nochrootscript:
            conf['NoChroot'] = nochrootscript
        return conf

    def process_files(self, meta, repos, global_repo_url_vars):
        new_repos = []

        if not meta.has_key('FileName') or not meta['FileName']:
            print "WARNING: FileName field missing. Ignoring config called '%s'." % meta['Name']
            return
        
        # Substitue repository values that are found.
        for repo in repos:
            r = {}
            r['Name'] = repo['Name']
            r['Url'] = repo['Url']
            if repo.has_key('Options'):
                r['Options'] = repo['Options']

            if meta.has_key("Architecture") and meta['Architecture']:
                # Prefer RepositoryArchitecture if present, otherwise use Architecture
                repo_arch = meta['Architecture']
                if meta.has_key('RepositoryArchitecture') and meta['RepositoryArchitecture']:
                    repo_arch = meta['RepositoryArchitecture']
                r['Url'] = r['Url'].replace("@ARCH@", repo_arch)
            if meta.has_key("RepositoryURLVariables") and meta['RepositoryURLVariables']:
		for variable in meta['RepositoryURLVariables']:
                    try:
                        (key,value) = variable.split(';')
                        r['Url'] = r['Url'].replace("%s" % (key), value) 
                    except ValueError:
                        print "WARNING: Ignoring invalid RepositoryURLVariables line: '%s'." % (variable)
            if global_repo_url_vars:
                for variable in global_repo_url_vars:
                    try:
                        (key,value) = variable.split(';')
                        r['Url'] = r['Url'].replace("%s" % (key), value)
                    except ValueError:
                        print "WARNING: Ignoring invalid global RepositoryURLVariables line: '%s'." % (variable)

            new_repos.append(r)

        # Check that all repos are actually found from repos data set
        if meta.has_key("Repos"):
            # Convert list to set to remove duplicated entries.
            # NOTE: This mixes the order that repos were introduced, but that 
            # shouldn't matter as all the handling is already over.
            meta['Repos'] = set(meta['Repos'])
            for selected_repo in meta['Repos']:
                found = False
                for repo in repos:
                    if repo['Name'] == selected_repo:
                        found = True
                        break
                if not found:
                    print "WARNING: Repository with name '%s' is not found, ignoring the repo for file '%s.ks'." % (selected_repo, meta['FileName'])

        nameSpace = {'metadata': meta,  'repos': new_repos}
        t = kickstart(searchList=[nameSpace])
        a = str(t)
        
        f = None
        
        if not os.path.exists(self.outdir):
            mkdir_p(self.outdir)
        
        ksFile = "%s/%s.ks" % ( self.outdir, meta['FileName'] )
        f = open(ksFile, 'w')
        print "Creating %s (%s)" %(conf['Name'], ksFile )
        f.write(a)
        f.close()

def recursive_yaml_load(stream,read_yaml_files):
    inp = yaml.load(stream)
    out = {}
    if not inp.has_key('ExternalConfigs') or not inp['ExternalConfigs']:
        return inp

    for path in inp['ExternalConfigs']:
        if not os.path.exists(path):
            print "WARNING: path '%s' doesn't exist ignoring." % (path)
            continue
        for f in os.listdir(path):
            if f.endswith('.yaml'):
                filename = '%s/%s' % (path, f)

                # Prevent infinite recusion loops
                if filename in read_yaml_files:
                    print "WARNING: File '%s' already read, ignoring the file." % (filename)
                    continue
                read_yaml_files.append(filename)

                fp = file(filename, 'r')
                ext = recursive_yaml_load(fp, read_yaml_files)
                for k,v in ext.iteritems():
                    if inp.has_key(k) and isinstance(v, list) and not isinstance(inp[k], list):
                        print "Different type (list vs not list) of values: %s in %s/%s" % (k, path, f)
                        break  
                    elif inp.has_key(k) and not isinstance(v, list) and isinstance(inp[k], list):
                        print "Different type (list vs not list) of values: %s in %s/%s" % (k, path, f)
                        break  
                    elif inp.has_key(k) and not isinstance(v, list):
                        print "Collision of values: %s in %s/%s" % (k, path, f)
                        break
                    elif inp.has_key(k) and isinstance(v, list):
                        # External configs come first
                        v.extend(inp[k])
                        out[k] = v
                    else:
                        out[k] = v
                for k,v in inp.iteritems():
                    # we already merged if it's already there
                    if not out.has_key(k):
                        out[k] = v
                inp = out
                out = {}
                        
    return inp

if __name__ == '__main__':
    parser = optparse.OptionParser()

    parser.add_option("-c", "--configs", type="string", dest="configsfile",
                    help="configuration meta file")
    parser.add_option("-o", "--outdir", type="string", dest="outdir",
                    help="outdir", default=".")
    (options, args) = parser.parse_args()

    if options.configsfile is None:
        print "you need to provide meta file with --configs"
        sys.exit(1)

    outdir = ""
    if options.outdir is None:
        outdir = "."
    else:
        outdir = options.outdir
    
    ks = KSWriter(outdir)

    if not os.path.isfile(options.configsfile):
        print "ERROR: Given configuration file is not file '%s'." % (options.configsfile)
        sys.exit(1)

    read_yaml_files = [ options.configsfile ]
    image_meta = recursive_yaml_load(file(options.configsfile, 'r'),read_yaml_files)

    repositories = None
    global_repo_url_vars = None
    if image_meta.has_key('Repositories') and image_meta['Repositories']:
        repositories = image_meta['Repositories']

    if image_meta.has_key('RepositoryURLVariables') and image_meta['RepositoryURLVariables']:
        global_repo_url_vars = image_meta['RepositoryURLVariables']

    if image_meta.has_key('Configurations') and image_meta['Configurations']:
        for configuration in image_meta['Configurations']:
            conf = ks.parse(image_meta, configuration)
            if conf.has_key('Active') and conf['Active']:
                ks.process_files(conf, repositories, global_repo_url_vars)
            else:
                filename = None
                if configuration.has_key('Filename') and configuration['Filename']:
                   filename = configuration['Filename']
                print "%s is inactive, not generating file '%s' this time." %(configuration['Name'], filename)
    else:
        print "WARNING: No 'Configurations' found from yaml."

